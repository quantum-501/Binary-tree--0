Common method（array）
- [ ] Hash table
- [ ] two pointers(middle, front, back,left-right) 
- [ ] sorting(merge, quick-sort, inserlation, bubble, selection)
- [ ] Slide window(substring,subarray)

String
- [ ] Panlidrome(two pointer, reverse)
- [ ] Anagram(sorting, frequency of counting, counting the character)
 
Graph
- [ ] Bread-first search（起点找branch，层层点点过，存入values，放seen true，点的edge一一查，不在就queue）
- [ ] Deep-first search（起点往内走到底，过一道是一道，values,graph,node,seen驷马并驾，存入values，放seen true，node边走边查edge，不在seen就递归）


Interval
- [ ] check overlapping { a[0]<b[1] && a[1]>b[0] }
- [ ] sorting the array by starting points { array.sort((a,b) => b[0]-a[0]//starting points descending order,  b[1]-a[1]//ending points descending order }
- [ ] Merging two intervals { [min(a[0],b[0]), max(a[1],b[1]] }


Binary tree
- [ ] inorder { left-root-right }
- [ ] preorder { root-left-right }
- [ ] postorder { left-right-root }

linked list 
- [ ] Tow pointers { where one is kth nodes ahead of the other. When the node ahead reaches the end, the other node is k nodes behind; Detecting cycles; 
Getting the middle node where one pointer increments twice as much as the other. When the faster node reaches the end of the list, the slower node will be at the middle}
- [ ] Using space { Many linked list problems can be easily solved by creating a new linked list and adding nodes to the new linked list with the final result.}
- [ ] Swapping values of node
- [ ] Combining two lists - attach the head of the second list to the tail of the first list
 {  
   reflection: 
   1.head in a linked list is not only the head but also includes a series of nodes behind it.
   2.every nodes contain own value and a pionter to next, when two linked list are compared with each other, comparison standard depends on their own value.
   3.a linked list that is not similar to array is comprised of unfixed node, for intance, even though a.next is b but their address arenot neighbours, a just pointer to b 
}

dynamic programming
- [ ] 


Regular pattern
string {substring}
    （1）越难的题目需要combined with hash table,two pointer,计算长短，三者并驾齐驱（2）三者也是动态关系，指针运动长度时，用max计算长短
    （2）substring was addressed by one attempt for employing acsending order that are used for giving the index of each strings,which represents the width of
        slide window will be depended on the distance of right pointer. and hash table could map shortest values/strings to check out original string.  
     {anagram}
     (1)hash table could map shortest values/strings to check out each original string while counting hash table at length, after meeting a string, 
     the length will minus. when hash table is equal to 0 or decrease one object, the counter will increment at the same time the width of slide window
     moved by the right pointer will look forward 

