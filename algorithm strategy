KeyAway:
-[]10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
-[]10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
-[]学习数据结构和算法的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”
-[]复杂度分析是数据结构和算法精髓，并占据了半壁江山

Big(O):
(1)时间复杂度（Time complexity）
-[]不仅所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比，而且代码执行时间随数据规模增长的变化趋势而增长。
-[]只关注循环执行次数最多的一段代码;总复杂度等于量级最大的那段代码的复杂度;嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
-[]一般情况下，算法中不存在循环语句、递归语句，即使有上万行的代码，其时间复杂度也是Ο(1)
-[]O(logn)、O(nlogn)是一段代码每循环一次logn，循环n次是nlogn;O(m+n)、O(m*n)是两段代码量级不知谁大谁小

(2)空间复杂度（asymptotic space complexity）
-[]表示算法的存储空间与数据规模之间的增长关系

Linked list:
-[]single list, doubled direction list, circle list, doubled circle list
-[]each node has own value and next pointer, except doubled direction list
-[]指针是指向内存地址，检查边界条件：如果链表为空时，代码是否能正常工作？如果链表只包含一个结点时，代码是否能正常工作？
                               如果链表只包含两个结点时，代码是否能正常工作？代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
-[]每次操作留意list指向的断裂-内存丢失-带头链表; 常见操作：按值查询，插入或删除某个“值的结点”&给定指针指向的结点

栈stack：
-[]后进者先出，先进者后出last out first in;只允许在一端插入和删除数据
-[]用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈
-[]常见应用场景：函数调用；括号匹配；表达式求值

队列queue：
-[]先进者先出first in first out;入栈enqueue()和出栈dequeue()；
-[]数组实现队列叫顺序队列,当请求超过队列大小时会拒绝请求,通过数据搬移来解决删除数据后数据不连续储存问题;链表实现队列叫链式队列,头尾指针也支持无限队列而过多排队队列等待请求时间过长
-[]当数组队列通过数据搬移会影响性能问题，而循环队列（首尾相连，成了一个环)每次入队一元素，让tail往后移一位要确定好队空和队满的判定条件（(tail+1)%n=head）
-[]队列特殊应用：阻塞队列（数据生产跟不上消费速度）并发队列（操作线程安全问题）
-[]应用领域:对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队;数据池;分布式应用中的消息队列

递归：
-[]一个问题的解可以分解为几个子问题;每个子问题除了数据规模不同，求解思路都一样；找出递归终止条件
-[]写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式(不要试图调用一层层关系和人脑去分解递归的每个步骤)，再推敲终止条件，最后将递推公式和终止条件翻译成代码
-[]警惕重复计算；堆栈溢出（堆栈内存空间有限);

排序Sorting
(1)如何分析“排序算法”
   -[]执行效率:1.最好情况、最坏情况、平均情况时间复杂度;2.数据规模较大时，时间复杂度系数,常数,低阶需要考虑;3.比较次数和交换（或移动）次数
   -[]算法内存消耗：原地排序（Sorted in place）就是特指空间复杂度是 O(1) 的排序算法
   -[]算法稳定性：这个概念是如果待排序的序列中存在值相等的元素，再排序后相等元素之间原有的先后顺序不变，eg稳定排序算法可以保持订单金额相同的两个对象，再次按照下单时间排序后前后顺序不变
(2)为什么插入排序要比冒泡排序更受欢迎呢？用冒泡排序，需要 K 次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3*K单位时间。而插入排序中数据移动操作只需要K个单位时间
(3)冒泡/插入/selection sort都是小规模数据采取排列方式，快速排序和合并排序是大规模数据sorted常用方式
(4)合并排序
   -[]用分治思想先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了;由下到上的，先处理子问题，然后再合并
   -[]空间复杂度是o(n）因为无法原地执行合并,也比较稳定
   快速排序
   -[]也用分治思想先要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot(分区点);是由上到下的，先分区，然后再处理子问题
   -[]通过设计巧妙的原地分区函数，实现原地排序，解决了归并排序占用太多内存的问题
   -[]原地、不稳定的排序算法;因为占用内存少，所以应用较多

回溯算法：把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。（本质上就是枚举
优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中）；

分治算法(divider and conquer):（分解）将原问题分解成一系列子问题（解决）递归地求解各个子问题，若子问题足够小，则直接求解（合并）将子问题的结果合并成原问题。

贪心算法:根据限制值，找出各个阶段达到期望值的最优解-->>(进化版）Dijkstra's Algorithm:解决graph整体最优解，例如最短时间延迟问题(指向值不能为负数）-->>(再次进化版)bellman-ford algorithm:
        解决graph中vertax指向值为负（不能解决negative circle);


字符串算法：初级（1）暴力算法（2）Rabin-Karp 算法【 即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间(让字母转化为26进制计算[b:1*26,c:2*26*26],
匹配字串段hash就是[起始位置,起始位置+长度-1]=h[i]=26^长度-1*(string[i]-‘a')+26^长度-2*（string[i-1]-‘a')+...+26^0*(string[i+m-1]-‘a')】;相邻字符之间hash值h[i]=(h[i-1]
-26^长度-1*string[i-1]-'a'))*26+26^0*((string[i+m-1]-'a')
（3）BM（Boyer-Moore）算法


Topological Sort(拓扑排序）（directed acyclic graph有向不循环图)
先统计所有节点的入度，对于入度为0的节点就可以分离出来，作为起点，然后把这个节点指向的节点的入度减一。一直做改操作，直到所有的节点都被分离出来。
