Trees — like linked lists — are made up of nodes and links.

- Root: the topmost node of the tree, which never has any links or edges connecting to it
- Link/Edge: the reference that a parent node contains that tells it what its child node is
- Child: any node that has a parent node that links to it
- Parent: any node that has a reference or link to another node
- Sibling: any group of nodes that are the children of the same node
- Internal: any node that has a child node (basically all parent nodes)
- Leaf: any node that does not have a child node in the tree

If a tree has n nodes, it will always have one less number of edges (n-1).

For the most part, the two properties that we will be the most concerned with are either the depth of a node or the height of a node.

The child node of a tree structure could also very well be the parent node to many other child nodes — which would effectively make it the root node of a mini subtree of the larger tree structure.

DAGs: A cycle in a diagraph or directed graph G is a set of edges 
The applications of DAGs include the following:
(1) Inheritance between C++ classes or Java interfaces.
(2) Prerequisites between courses of a degree program.
(3) Scheduling constraints between the tasks of a projects.


// Javascript program to print DFS(Depth First Search or DFS for a Graph)
// traversal from a given graph

// This class represents a
// directed graph using adjacency
// list representation
class Graph
{
	
	// Constructor
	constructor(v)
	{
		this.V = v;
		this.adj = new Array(v);
		for(let i = 0; i < v; i++)
			this.adj[i] = [];
	}
	
	// Function to add an edge into the graph
	addEdge(v, w)
	{
		
		// Add w to v's list.
		this.adj[v].push(w);
	}
	
	// A function used by DFS
	DFSUtil(v, visited)
	{
		
		// Mark the current node as visited and print it
		visited[v] = true;
		document.write(v + " ");

		// Recur for all the vertices adjacent to this
		// vertex
		for(let i of this.adj[v].values())
		{
			let n = i
			if (!visited[n])
				this.DFSUtil(n, visited);
		}
	}
	
	// The function to do DFS traversal.
	// It uses recursive
	// DFSUtil()
	DFS(v)
	{
		
		// Mark all the vertices as
		// not visited(set as
		// false by default in java)
		let visited = new Array(this.V);
		for(let i = 0; i < this.V; i++)
			visited[i] = false;

		// Call the recursive helper
		// function to print DFS
		// traversal
		this.DFSUtil(v, visited);
	}
}

// Driver Code
g = new Graph(4);

g.addEdge(0, 1);
g.addEdge(0, 2);
g.addEdge(1, 2);
g.addEdge(2, 0);
g.addEdge(2, 3);
g.addEdge(3, 3);

document.write("Following is Depth First Traversal " +
			"(starting from vertex 2)<br>");

g.DFS(2);

// This code is contributed by avanitrachhadiya2155
