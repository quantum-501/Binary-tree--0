KeyAway:
-[]10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
-[]10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
-[]学习数据结构和算法的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”
-[]复杂度分析是数据结构和算法精髓，并占据了半壁江山

Big(O):
(1)时间复杂度（Time complexity）
-[]不仅所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比，而且代码执行时间随数据规模增长的变化趋势而增长。
-[]只关注循环执行次数最多的一段代码;总复杂度等于量级最大的那段代码的复杂度;嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
-[]一般情况下，算法中不存在循环语句、递归语句，即使有上万行的代码，其时间复杂度也是Ο(1)
-[]O(logn)、O(nlogn)是一段代码每循环一次logn，循环n次是nlogn;O(m+n)、O(m*n)是两段代码量级不知谁大谁小

(2)空间复杂度（asymptotic space complexity）
-[]表示算法的存储空间与数据规模之间的增长关系


Linked list:
-[]single list, doubled direction list, circle list, doubled circle list
-[]each node has own value and next pointer, except doubled direction list
-[]指针是指向内存地址，检查边界条件：如果链表为空时，代码是否能正常工作？如果链表只包含一个结点时，代码是否能正常工作？
                               如果链表只包含两个结点时，代码是否能正常工作？代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
-[]每次操作留意list指向的断裂-内存丢失-带头链表; 常见操作：按值查询，插入或删除某个“值的结点”&给定指针指向的结点


回溯算法：把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。（本质上就是枚举
优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中）；

分治算法(divider and conquer):（分解）将原问题分解成一系列子问题（解决）递归地求解各个子问题，若子问题足够小，则直接求解（合并）将子问题的结果合并成原问题。

贪心算法:根据限制值，找出各个阶段达到期望值的最优解-->>(进化版）Dijkstra's Algorithm:解决graph整体最优解，例如最短时间延迟问题(指向值不能为负数）-->>(再次进化版)bellman-ford algorithm:
        解决graph中vertax指向值为负（不能解决negative circle);


字符串算法：初级（1）暴力算法（2）Rabin-Karp 算法【 即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间(让字母转化为26进制计算[b:1*26,c:2*26*26],
匹配字串段hash就是[起始位置,起始位置+长度-1]=h[i]=26^长度-1*(string[i]-‘a')+26^长度-2*（string[i-1]-‘a')+...+26^0*(string[i+m-1]-‘a')】;相邻字符之间hash值h[i]=(h[i-1]
-26^长度-1*string[i-1]-'a'))*26+26^0*((string[i+m-1]-'a')
（3）BM（Boyer-Moore）算法


Topological Sort(拓扑排序）（directed acyclic graph有向不循环图)
先统计所有节点的入度，对于入度为0的节点就可以分离出来，作为起点，然后把这个节点指向的节点的入度减一。一直做改操作，直到所有的节点都被分离出来。
