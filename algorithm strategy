KeyAway:
-[]10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
-[]10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
-[]学习数据结构和算法的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”
-[]复杂度分析是数据结构和算法精髓，并占据了半壁江山
-[]学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法
-[]物理存储结构就两种，连续存储、离散式存储;算法是根据应用场景需求，对物理存储结构进行改造和组合的奇技淫巧;数据结构就是指逻辑结构，是适合某一算法发挥和理解的物理存储结构的改造和组合。
所以数据结构就是为了算法而生的


Big(O):
(1)时间复杂度（Time complexity）
-[]不仅所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比，而且代码执行时间随数据规模增长的变化趋势而增长。
-[]只关注循环执行次数最多的一段代码;总复杂度等于量级最大的那段代码的复杂度;嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
-[]一般情况下，算法中不存在循环语句、递归语句，即使有上万行的代码，其时间复杂度也是Ο(1)
-[]O(logn)、O(nlogn)是一段代码每循环一次logn，循环n次是nlogn;O(m+n)、O(m*n)是两段代码量级不知谁大谁小

(2)空间复杂度（asymptotic space complexity）
-[]表示算法的存储空间与数据规模之间的增长关系

Linked list:
-[]single list, doubled direction list, circle list, doubled circle list
-[]each node has own value and next pointer, except doubled direction list
-[]指针是指向内存地址，检查边界条件：如果链表为空时，代码是否能正常工作？如果链表只包含一个结点时，代码是否能正常工作？
                               如果链表只包含两个结点时，代码是否能正常工作？代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
-[]每次操作留意list指向的断裂-内存丢失-带头链表; 常见操作：按值查询，插入或删除某个“值的结点”&给定指针指向的结点

栈stack：
-[]后进者先出，先进者后出last out first in;只允许在一端插入和删除数据
-[]用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈
-[]常见应用场景：函数调用；括号匹配；表达式求值

队列queue：
-[]先进者先出first in first out;入栈enqueue()和出栈dequeue()；
-[]数组实现队列叫顺序队列,当请求超过队列大小时会拒绝请求,通过数据搬移来解决删除数据后数据不连续储存问题;链表实现队列叫链式队列,头尾指针也支持无限队列而过多排队队列等待请求时间过长
-[]当数组队列通过数据搬移会影响性能问题，而循环队列（首尾相连，成了一个环)每次入队一元素，让tail往后移一位要确定好队空和队满的判定条件（(tail+1)%n=head）
-[]队列特殊应用：阻塞队列（数据生产跟不上消费速度）并发队列（操作线程安全问题）
-[]应用领域:对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队;数据池;分布式应用中的消息队列

递归recursion：
-[]一个问题的解可以分解为几个子问题;每个子问题除了数据规模不同，求解思路都一样；找出递归终止条件
-[]写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式(不要试图调用一层层关系和人脑去分解递归的每个步骤)，再推敲终止条件，最后将递推公式和终止条件翻译成代码
-[]警惕重复计算；堆栈溢出（堆栈内存空间有限);

排序Sorting
(1)如何分析“排序算法”
   -[]执行效率:1.最好情况、最坏情况、平均情况时间复杂度;2.数据规模较大时，时间复杂度系数,常数,低阶需要考虑;3.比较次数和交换（或移动）次数
   -[]算法内存消耗：原地排序（Sorted in place）就是特指空间复杂度是 O(1) 的排序算法
   -[]算法稳定性：这个概念是如果待排序的序列中存在值相等的元素，再排序后相等元素之间原有的先后顺序不变，eg稳定排序算法可以保持订单金额相同的两个对象，再次按照下单时间排序后前后顺序不变
(2)为什么插入排序要比冒泡排序更受欢迎呢？用冒泡排序，需要 K 次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3*K单位时间。而插入排序中数据移动操作只需要K个单位时间
(3)冒泡/插入/selection sort都是小规模数据采取排列方式，快速排序和合并排序是大规模数据sorted常用方式
(4)合并排序
   -[]用分治思想先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了;由下到上的，先处理子问题，然后再合并
   -[]空间复杂度是o(n）因为无法原地执行合并,也比较稳定
   快速排序
   -[]也用分治思想先要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点);是由上到下的，先分区，然后再处理子问题
   -[]通过设计巧妙的原地分区函数，实现原地排序，解决了归并排序占用太多内存的问题
   -[]原地、不稳定的排序算法;因为占用内存少，所以应用较多
(5)时间复杂度o(n)是线性的排序(掌握这些排序算法的适用场景)
   -[]捅排序(bucket sort)：（适合用在外部排序中。所谓外部排序是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中）
      - 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的
      - 要求排序数据是非常苛刻：排序的数据需要很容易就能划分成m个天然大小均匀的桶，并且不用对桶排序;
   -[]计数排序(Counting sort）
      - 是桶排序的一种特殊情况。当要排序的n个范围不大的数据时，比如最大值是 k，可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间；
        Eg:将50万考生划分到代表0-900分的901个分数桶内的数据都是分数相同的考生,所以并不需要再进行排序,这是数组c,另一个数组r来计算排名，c[499]分数桶内的总人数==r[总人数-1]中value(499)
           当c[499]中总人数移出一个到r[总人数]的位置后，c[499]的value(总人数-1)对应的就是r[总人数-2]的value(499);
      - 计数排序只能用在数据范围不大的场景中,如果数据范围k比要排序的数据n大很多，就不适合用了。而且只能给非负整数排序，如果排序的数据是其他类型的，要不改变相对大小的情况下，转化为非负整数
    -[]基数排序(Radix sort)
     - 对要排序的数据是要求可以分割出独立递进关系的“位”来比较,如果a数据的高位比b数据大,那剩下的低位就不用比较了.
     - 每一位的数据范围不能太大并可以用线性排序算法来排序，否则基数排序的时间复杂度就无法做到O(n)了
(6)如何优化并实现高性能排序？
    -[]线性排序应用特殊场景,冒泡/插入/selection排序的时间复杂度O(n2),加上这些处理的数据规模比较轻量级,所以这两大选项被排除；
    -[]归并和快速排序都为时间复杂度O(nlogn),可归并不是原地排序导致需更多空间内存，这会增加空间复杂度，而快排相的时间最坏情况也就O(n2)既是稳定和原地排序，可以实现再优化性能
    -[]优化最坏情况下快排时间复杂度O(n2)的关键是划分数据量均匀的分,也就是分区点合理!首尾中间值三数比较中间数作为分区点或随机选择一个点作为分区，但会引发时间O(n2)可能性;
    
二分查找binary search
-[]用分区分治思想将有序数据集合不断通过与区间的中间元素对比,将待查找区间缩小为之前一半,直到目标元素出现,或区间缩小为0;
-[]中间值最理想的取值是low+(high-low)/2,循环退出条件low<=high,low和high的更新是low=mid+1，high=mid-1
-[]应用场景限制:采用有序数据表并随机访问为主，所以数组合适;数据量太大或太小都不合适二分查找
    
散列表hash table
-[]按照数组的下标随机访问数据特性，所以散列表像是数组的一种扩展，由数组演化而来，如果没有数组，就没有散列表;hash键标识作为标识通过数组下标的映射方法（hash函数）计算hash值散列值
(1)hash函数设计
   -[]如果key1=key2,那么hash[key1]==hash[key2];如果key1不等于key2,那hash(key1)≠hash(key2);散列函数计算得到的散列值是一个非负整数;
   -[]复杂设计会导致更多运行时间和性能；
   -[]散列函数生成的值要尽可能随机并且均匀分布
(2)hash冲突（数组储存空间有限，查插删操作的计算成本大，会导致地址内存发生冲突）
   -[]开放寻址法（数据量比较小、装载因子小时适合用）：让数组按照当前位置一次往后探测空地址（线性探测）,直到找到;为了避免预留一个被删除元素而被新元素占有,会在这地址上,标记deleted;
   -[]但空闲位置越来越小时,线性探测就是越来越耗费时间复杂度，所以采取二次探测（探测步长就变成了下标“二次方”);双重散列（如果计算存储位置在一散裂函数被占用，再用第二个，直到有空闲位置）
   -[]装载因子（预设它避免冲突发生并保证执行效率）：散列表的装载因子=填入表中的元素个数/散列表的长度
   -[]链表法（适合大数据量存储）:将散列值相同元素放到相同槽位每个“桶”或“slot”后的链表中,插查删操作通过hash table计算对应槽位然后遍历链表，时间复杂度和链表长度k正比关系，k=散列中数据的个数/散列表中“槽”的个数
 (3)装载因子太大怎么办？
   -[]超过装载因子阈值时,像数组,队栈自那样动态扩容,均摊或最好情况(1)<时间复杂度<(n),但阈值也要控制合理,不能过大(内存浪费)过小(执行效率慢)；适当情况下也缩容
   如何避免低效扩容？
   -[]每次新数据插入操作新列表时，重复从老列表提取数据到新列表,直到搬完。
   -[]查询操作，先从新散列表中查找，如果没有找到，再去老的散列表中查找。
   
树tree
  -[]像树状一样由根节点到叶子节点散发，既有高度（根节点到叶子结点的最长路径）深度（根节点到叶子经历边的个数）层数（深度+1）树高度（根节点高度）
  -[]二叉树最常用，满二叉树(从上往下每个节点都有完整子节点)完全二叉树(最底层子节点向左排列,除最后层,其他层节点个数都到最大);链式存储(一节点有节点值和左右两个指针)和数组顺序存储(从上到下左往右顺序存）
  -[]前中后三张遍历方式
（1）二叉查询树（排序树）左子树比根节点小，右子树比根节点大
   -[]查询操作：操作数值与根节点大小比较，大了往右走，小了往左走
   -[]插入操作：操作数值与根结点大小比较并判断子树是否为空，空了直接插入位置，不空就递归
   -[]删除操作：当待删除节点无子节点，就直接让指向的父节点为null；当待删除节点有子节点，让子节点被父父节点指针指向；当待删除节点有两子节点,找到右子树的最小节点与其替换
   -[]其他操作：快速地查找最大节点和最小节点、前驱节点和后继节点;
   -[]中序遍历二叉查找树,可以输出有序的数据序列,时间复杂度是 O(n);完全二叉树时间复杂度是由层决定2^(层数-1）
 (2)平衡二叉树（红黑树）因为二叉查找树应对动态更新时性能下降很大
   -[]“平衡”是树外观”对称“,左右子树高度相差不超过1，红黑树被通俗为平衡二叉树
   -[]红黑树特点:根节是黑色;叶子节点是黑色空节点(不存储数据);任何相邻节点不能同为红色，红节点是被黑节点隔开的；每个节点到达其可达叶子节点所有路径，都是相同数目黑色节点
   -[]时间复杂度是2log2n;红黑树插入、删除、查找各种操作性能都比较稳定;
   -[]平衡二叉查找树插入效率高，但插入删除的数据集合性能不稳定;
 
 如何用递归树分析时间复杂度？
  -[]所有能转为递归树的数据结构都要考虑其高度h和个数(层数)n来计算时间复杂度
  -[]递归
  -[]通过分析时间复杂度也可以分析出递归解法！！
    
堆heap
-[]完全二叉树(最后一层向左对齐，其他层节点都最大)+父节点比子树节点大（小)；大顶堆（堆顶值最大）小顶堆（堆顶值最小）
-[]heapify堆化：插入一个数据是将新数据放最后一个位置，然后从下往上堆化；删除堆顶数据是让最后数据与堆顶交换然后从上往下堆化
-[]堆排序（经典应用):
   - 建堆(a按照数组下标从1起插入2到n数据到堆中;b从前往后处理数据实现从下往上堆化c从后往前处理数据,每次选择下标n/2节点开始，然后从上往下堆化)
   - 排序(建堆后堆顶为最大，然后把其放末尾，并减去堆一个元素，再堆化，重复上述步骤，直到最后一个元素，就实现了有序排列了.
-[]应用场景：
   - 优先级队列：把堆看作优先级队列，实行先进先出；
   - 求TopK问题：实行K大小的小顶堆,首先添加数据,比对堆顶大小，小了放弃，大了入堆
   - 求中位数问题
     - 静态数据：长度为奇数取n/2，长度为偶数取n/2+1，直接返回n/2中间值
     - 动态数据：前半数据进大堆顶all数据<<后半数据进小堆顶all数据，然后询问输入值大小，大了进小堆，小了进大堆，两个再堆化，大堆顶就是中间数(考虑奇偶数)

图graph
-[]节点之间边是代表两点之间有关系，分为有向权重图，无向权重图，无向图，有向图
-[]邻接矩阵(Adjacency Matrix)，无向图来说，如果A[i][j]等于1，那A[j][i]也肯定等于1,但会浪费内存,查询效率高且方便矩阵运算
-[]邻接表(Adjacency List)每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点;查询效率低且不省空间
-[]广度优先搜索（Breadth-First-Search)  深度优先搜索(DFS)两种最常用、最基本的搜索算法


字符串算法
-[]Brute Force算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串；时间复杂度O(n*m)，n,m表示主串和模式串的长度
-[]Rabin-Karp算法是借助哈希算法对BF算法进行改造，即对每个子串分别求哈希值，然后子串与模式串的哈希值比,减少了比较时间；时间复杂度O(n)但决于哈希算法的设计方法,极端情况下出现大量冲突,会退化为 O(n*m)


回溯算法：把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。（本质上就是枚举
优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中）；

分治算法(divider and conquer):（分解）将原问题分解成一系列子问题（解决）递归地求解各个子问题，若子问题足够小，则直接求解（合并）将子问题的结果合并成原问题。

贪心算法:根据限制值，找出各个阶段达到期望值的最优解-->>(进化版）Dijkstra's Algorithm:解决graph整体最优解，例如最短时间延迟问题(指向值不能为负数）-->>(再次进化版)bellman-ford algorithm:
        解决graph中vertax指向值为负（不能解决negative circle);


字符串算法：初级（1）暴力算法（2）Rabin-Karp 算法【 即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间(让字母转化为26进制计算[b:1*26,c:2*26*26],
匹配字串段hash就是[起始位置,起始位置+长度-1]=h[i]=26^长度-1*(string[i]-‘a')+26^长度-2*（string[i-1]-‘a')+...+26^0*(string[i+m-1]-‘a')】;相邻字符之间hash值h[i]=(h[i-1]
-26^长度-1*string[i-1]-'a'))*26+26^0*((string[i+m-1]-'a')
（3）BM（Boyer-Moore）算法


Topological Sort(拓扑排序）（directed acyclic graph有向不循环图)
先统计所有节点的入度，对于入度为0的节点就可以分离出来，作为起点，然后把这个节点指向的节点的入度减一。一直做改操作，直到所有的节点都被分离出来。

动态数据结构有链表，栈，队列，哈希表等等。
-链表适合遍历的场景，插入和删除操作方便，栈和队列可以算一种特殊的链表，分别适用先进后出和先进先出的场景。
-哈希表适合插入和删除比较少（尽量少的扩容和缩容），查找比较多的时候。
-红黑树对数据要求有序，对数据增删查都有一定要求的时候
