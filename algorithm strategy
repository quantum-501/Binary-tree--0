回溯算法：把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。（本质上就是枚举
优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中）；

分治算法(divider and conquer):（分解）将原问题分解成一系列子问题（解决）递归地求解各个子问题，若子问题足够小，则直接求解（合并）将子问题的结果合并成原问题。

贪心算法:根据限制值，找出各个阶段达到期望值的最优解-->>(进化版）Dijkstra's Algorithm:解决graph整体最优解，例如最短时间延迟问题(指向值不能为负数）-->>(再次进化版)bellman-ford algorithm:
        解决graph中vertax指向值为负（不能解决negative circle);


字符串算法：初级（1）暴力算法（2）Rabin-Karp 算法【 即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间(让字母转化为26进制计算[b:1*26,c:2*26*26],
匹配字串段hash就是[起始位置,起始位置+长度-1]=h[i]=26^长度-1*(string[i]-‘a')+26^长度-2*（string[i-1]-‘a')+...+26^0*(string[i+m-1]-‘a')】;相邻字符之间hash值h[i]=(h[i-1]
-26^长度-1*string[i-1]-'a'))*26+26^0*((string[i+m-1]-'a')
（3）BM（Boyer-Moore）算法
