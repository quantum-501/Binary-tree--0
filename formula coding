Two Loop instance:
bubbleSort（依次遍历出最大至最小值） - insertionSort（每个值都与unsorted list比较大小，直到达到升序排列） - selection sort（找出最小的值往前移动）

MULTIBLE Functions instance:
quickSort（根据pviot用分割函数分成两个比他大小的部分，大小部分再分割函数，每部分再对值和交换 - mergeSort(divider and conquer，把数分出两部分排序，两部分再分成为两个部分，
合计四个部分再分成为八个部分排序)

Searching:
binary searching(left,mid,right是基础,左右部分搜索也可以)

Two Pointer:
前后交接移动，从外向里移动，从里向外看移动，slide window移动方式(左边等右边满足条件移动), 
for instance: 2sum(两数之和等于target), 3sum(2+1等于2指针) Largest Rectangle in Histogram (calculating length and width flexibly) this solution includes dynamic slide window and two pointers techniques.
Trapping rainwater()

Hash table:
map.set(n,map.get(n)+1 || 1); if(!map[n]) map[n] =1 else map[n]++;

Linked list(singled list)
A.Tow pointers { the former one is faster kth nodes than the latter one( two benefits:1.it could check whether one circle link is true, 2. the former one 
is twice speed as much as the latter one, the slow one will reach the middle of list while the former is at the end of links), another instance:two pointer
could be used to seting two lines in one heap(example: remove kth node from the end of node)}.
B. deploying a new linked list to add old nodes in order to accomplish a aim
C. Combining two lists - attach the head of the second list to the tail of the first list
D. insertion,deletion,reverse linked list, swap two nodes' values


Interval（ from most interval question, array has been sorted in ascending order or descending order，so it will cut down one factor being considered)
A. Soring the array of intervals by its starting point
B. Merge interval ( [min(a[0], b[0]), max(a[1], b[1])])
C. check if over-lapping interval (return a[0] < b[1] and b[0] < a[1])

Tree
- [ ]Binary tree 
A.Traversing by level (bread-first search)
B.Using recursion （deep-first search)
-  inorder { left-root-right }
-  preorder { root-left-right }
-  postorder { left-right-root }

Breadth First Traversal: 1 2 3 4 5 or 1 2 3 5 4 or 1 3 2 4 5 or 1 3 2 5 4 

Depth First Traversals: 
      Preorder Traversal : 1 2 4 5 3 
      Inorder Traversal  : 4 2 5 1 3 
      Postorder Traversal : 4 5 2 3 1

for intsance: Level Order Binary Tree Traversal; Iterative Preorder Traversal;Iterative Postorder Traversal(with 2 stacks)

- [ ]Binary search tree
left is always less than node, and right is always greater than node.

Level Order Binary Tree Traversal
function printLevelOrder() {
        var queue = [];
        queue.push(root);
        while (queue.length != 0) {
            
            var tempNode = queue.shift();
            document.write(tempNode.data + " ");
 
            if (tempNode.left != null) {
                queue.push(tempNode.left);
            }

            if (tempNode.right != null) {
                queue.push(tempNode.right);
            }
        }
    }



Iterative Preorder Traversal
function iterativePreorder(node)
{
	if (node == null)
	{
		return;
	}
	var nodeStack = [];
	nodeStack.push(root);

	while (nodeStack.length > 0)
	{
		
		
		var mynode = nodeStack[nodeStack.length - 1];
		document.write(mynode.data + " ");
		nodeStack.pop();
		
		if (mynode.right != null)
		{
			nodeStack.push(mynode.right);
		}
		if (mynode.left != null)
		{
			nodeStack.push(mynode.left);
		}
	}
}


Iterative Postorder Traversal(with 2 stacks)
function postOrderIterative(root) {
        var s1 = [];
        var s2 = [];
 
        if (root == null) return;
        
        s1.push(root);
 
        while (s1.length > 0) {
          var temp = s1.pop();
          s2.push(temp);
 
          if (temp.left != null) s1.push(temp.left);
          if (temp.right != null) s1.push(temp.right);
        }

        while (s2.length > 0) {
          var temp = s2.pop();
          document.write(temp.data + " ");
        }
 }

Detected Cycle
var hasCycle = function(head) {
    if(!head) {
        return false;
    }
    let hare = head;
    let tortoise = head;
    while(hare) {
        if(!hare.next) {
            return false;
        } else {
            hare = hare.next.next;
            tortoise = tortoise.next;
        }
        if(tortoise == hare) {
            return true;
        }
    }
    return false;
};

Deploying two pointer in one heap: remove kth node from the end of list
var removeNthFromEnd = function(head, n) {
 let fast = head, slow = head
    for (let i = 0; i < n; i++) fast = fast.next
    if (!fast) return head.next
    while (fast.next) fast = fast.next, slow = slow.next
    slow.next = slow.next.next
    return head
}

TwoSum:
var twoSum = function(nums, target) {
      const map = {};
  for (let i = 0; i < nums.length; i++) {
    const another = target - nums[i];

    if (another in map) {
      return [map[another], i];
    }

    map[nums[i]] = i;
  }

  return null;
};

ThreeSum:
var threeSum = function(nums) {
    nums.sort((a, b) => a - b);
    const result = [];
    
    for(let i = 0; i < nums.length; i++) {
        let low = i+1, high = nums.length-1, sum = 0;
        
        while(low < high) {
            sum = nums[i] + nums[low] + nums[high];
            
            if(sum === 0) {
                result.push([nums[i], nums[low], nums[high]]);
                while(nums[low+1] === nums[low]) low++;
                while(nums[high-1] === nums[high]) high--;
                low++;
                high--;
            } else if(sum < 0) low++;
            else high--;
        }
        while(nums[i+1] === nums[i]) i++;
    }
    return result;    
};

//trapping rainywater
const elevationArray = [0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2]

const getTrappedRainwater = function(heights) {

  let left = 0, right = heights.length - 1, totalWater = 0, maxLeft = 0, maxRight = 0;
  
  while(left < right) {
    if(heights[left] <= heights[right]) {
      if(heights[left] >= maxLeft) { 
        maxLeft = heights[left]
      } else { 
        totalWater += maxLeft - heights[left];
      }
      left++;
    } else {
      if(heights[right] >= maxRight) {
          maxRight = heights[right];
      } else {
          totalWater += maxRight - heights[right];
      }
        
      right--;
    }
  }

  return totalWater;
}


console.log(getTrappedRainwater(elevationArray));

Largest Rectangle in Histogram:
var largestRectangleArea = function(heights) {
   let maxArea = 0;
    let currArea = 0;
    
    for (let i = 0; i < heights.length; i++) {
        let l = i-1;                          
        let r = i+1;
    
        let currHeight = heights[i];
      
        if (heights[r] === currHeight) continue;
        
        currArea = currHeight;
           
        while (l >= 0 && heights[l] >= currHeight) {
            currArea += currHeight;
            l--;
        }
        
        while (r < heights.length && heights[r] >= currHeight) {
            currArea += currHeight;
            r++;
        }
        
        maxArea = Math.max(currArea, maxArea);
        currArea = 0;
    }
    return maxArea;
};


Binary searching:
var search = function(nums, target) {
    if (nums.length === 0) return -1; 

  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);

    if (nums[mid] === target) return mid;

    // left sorted
    if (nums[left] <= nums[mid]) {
      
      // check if is in the left sorted part
      if (nums[left] <= target && target < nums[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
   
    // right sorted
    } else {
      // check if is in the right sorted part
      if (nums[mid] < target && target <= nums[right]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
  }
  return -1;
};

Quick Sort:
quickSort(array,leftIndex,rightIndex){
  var pviot;
  if(array.length>1){
      pviot = partition(array,leftIndex,rightIndex);
  }
  if(leftIndex < pviot-1){
       quickSort(array,leftIndex,pviot-1);
  }
  if(rightIndex > pviot){
       quickSort(array,pviot,rightIndex);
  }
}

function partition(array,left,right){
    var pviot = array[Math.floor(left+right)/2];
    
    while(left < right){

     while(array[left]< pviot){
       left++;
     }
    
     while(array[right]>pviot){
       right--;
     }
     
     // swap. values
     if(left<=right){
       let current = array[left];
       array[left] = array[right];
       array[right] = current;
       left++;
       right--;
     }
    
   }
   return left;
}

mergeSort:
function mergeSort(array){

    if(array.length<1) return;
    
    var midpoint = Math.floor(array.length/2);
    var leftarray = array.slice(left,midpoint-1);
    var rightarray = array.slice(midpoint,right);
    
    mergeSort(leftarray);
    mergeSort(rightarray);
    
    merge(array,left);
    
    return array;
}

function merge(leftarray,rightarray,array){
    var index = 0;
    while(leftarray&&rightarray){
      if(leftarray <= rightarray){
        array[index++] = leftarray.unshift();    
      }
      if(leftarray >= rightarray){
         array[index++] = rightarray.unshift();
      }
    }
    
    while(leftarray){
      array[index++] = leftarray.unshift();
    }
    while(rightarray){
      array[index++] = rightarray.unshift();
    }
}

insertion sort

insetionSort(array){
        for(let i=1；i<array.length; i++){
        let current = array[i];
        for(let j=i; j>0 && current < array[j-1]; j--){
             array[j] = array[j-1];
          }
          array[j]=current;
        }
    return array
}

bubbleSort   // 
bubbleSort(array){
       var sorted = false;
     while(!sorted){
         sorted = true;
        for(let i = 0; i< array.length; i++){
           if(array[i] = array[i+1]{
             sorted = false;
             var current = array[i+1];
                 array[i+1] = array[i];
                 array[i] = current;
           }
         }
       }
      return array;
}


selection sort
selectionSort(array){
   for(let index=0;i<array.length-1;i++){
     var smallest = index;
     for(let j=i+1;j<array.length-1;j++){
         if(array[smallest] < array[index];
         smallest = index;
     } 
  }
   
   if(smallest != index){
   let current = array[index];
   array[index] = array[smallest];
   array[smallest] = array[index];
   }
   return array;
}
