

从输入URL到到页面展示(页面导航)
渲染进程----------------------------------------------------------------提---交---文---档---->>>>>>>---页面解析和子资源加载
                                                                     ｜(与网络进程建立数据通道)｜            ｜
浏览器进程--输入url--解析用户请求--开始导航(响应头数据和信息) ---(重定向)---准备渲染进程-->>--确认文档提交->>-页面加载完成
                                 ｜                                  ｜
网路进程----------------------发起URL请求--(重定向)--读取响应头-----返回解析完响应数据-->>--响应体数据解析--


浏览器缓存机制：
请求-有缓存?-->有>-是否过期->是>-是否缓存标识-->无>--协商缓存判断Elag-->有>--向服务器请求if-none-match--------服务器返回200或304--------->--------304-->>---
       ｜             ｜                                ｜                                                  |^                  ｜                |
       ｜             no                                 ->无>-判断Lastmodfied-->yes>--判断向服务器请求if-modified-since           200        服务器返304读本地缓存
       无             ｜                                             |无                                                        ｜                |
       ｜        直接读取缓存内容		                    服务器请求------------------->>>>------------------------请求响应/缓存协商--->---返请求资源
        ----------------------------------------------------------------------------------------------------------------------------------------^^

 
浏览器页面加载流水线：
加载主页面 --阻止-- 构建dom（响应html数据） --阻止--  执行javascript(v8事件循环)---继续构建dom---构建cssom（css解析）---构建布局树---渲染---分层--分快--合成
｜       HTMLparser解析|    |(预解析）                  ｜(响应javascript数据）                ｜(响应javascript数据）                ｜
网络资源请求 ------------    ----开始请求javascript文件----                                    ｜                                  帧（显示屏计算）
                           -----开始请求css文件-----------------------------------------------

浏览器页面循环系统：
消息队列输入或输出任务按照先进先出顺序给事件循环主线程中执行，i/o进程不仅接受网络进程和浏览器上任务而且将每项交互事件给消息队列
为了解决执行任务实时性和效率性，算入微任务，其在主函数结束之后，宏任务(用户交互,页面渲染,IO输入,JavaScript脚本事件,网络请求读写事件)未结束前异步执行的函数
async function foo() { 
console.log('foo')  // 5.创建一个Promise返回给主协程 
}
async function bar() {    
console.log('bar start') // 3.将控制权交给协程,输出bar start, 
await foo()    // 4.碰到await,执行foo,输出foo
console.log('bar end') //8.当前task结束之前检查微任务队列，执行第一个微任务，将控制器交给协程输出bar end
}
console.log('script start') // 1.首先在主协程中初始化异步函数foo和bar，碰到console.log打印script start；
setTimeout(function () {  // 2. 解析到setTimeout，初始化一个Timer，创建一个新延迟执行task在queue中
console.log('setTimeout')}, 0) //10.当前任务执行完毕进入下一个任务，输出setTimeout
bar();  //3.执行bar函数
new Promise(function (resolve) {  // 6.将返回的promise添加到微任务队列，向下执行 new Promise，输出 promise executor
console.log('promise executor')    
resolve(); 
}).then(function () {  
console.log('promise then'). //9. 执行第二个微任务 输出 promise then
})
console.log('script end') //7.输出script end



网络连接
http1出现应对万维网产生的数据苛刻要求日益增长,支撑多种数据类型，数据文件大小，数据编码形式，语言版本来应对多样化网络需求，在这基础上,引出数据压缩,服务器处理状态码,cache缓存处理,
用户数量（称为用户代理）；
持续更新的http1.1:持久tcp连接,一域名有六个tcp连接,域名分片机制,队头阻塞,虚拟机支持为解决不同主机ip的host字段,数据分割多个小数据包,动态内容；

依然存在问题是：底宽利用率低,因为tcp慢启动,多个tcp连接会竞争固定带宽，队头阻塞；
为解决这个问题，http2提出了多路复用：一个域名对应一个持久tcp连接和消除队头阻塞。实现原理，将post带有的请求头行体进入二进制分帧层，被其带上id编号帧传入服务器，然后整体处理再返回到
二进制分帧层，被根据id回应原请求。另外也增加了请求优先级,头部压缩,服务器推送（直接拿html后，等于拿到html附带css和js文件一起被解析）

TCP的队头堵塞，网络延迟和协议僵化，无法让http有更大进展，所以http3出来了基于udp的quic协议，绕过tcp协议
拥有：多线路复用，快速握手（0或1rtt连接),tls1.3，传输可靠，流量控制等功能


js工作原理：编译阶段--执行阶段

1.js先把var和function函数提升至语法环境中,let和const放进词法环境,创建执行全局上下文放在函数调用栈中并都为undefined,然后执行语句中对应变量名赋值,每个被执行的函数都会放在栈中,每次
执行一个就从pop一个，如果某个函数内部没有找到对应变量名，那么栈中函数上下文的outer就会从全局上下文中的词法环境开始找到语法环境中去。
2.词性作用域链决定作用域链各自范围,闭包受其影响,即使闭包所在函数体执行结束后被pop,但是闭包存在词法环境内依然存在.



Trees — like linked lists — are made up of nodes and links.

- Root: the topmost node of the tree, which never has any links or edges connecting to it
- Link/Edge: the reference that a parent node contains that tells it what its child node is
- Child: any node that has a parent node that links to it
- Parent: any node that has a reference or link to another node
- Sibling: any group of nodes that are the children of the same node
- Internal: any node that has a child node (basically all parent nodes)
- Leaf: any node that does not have a child node in the tree

If a tree has n nodes, it will always have one less number of edges (n-1).

For the most part, the two properties that we will be the most concerned with are either the depth of a node or the height of a node.

The child node of a tree structure could also very well be the parent node to many other child nodes — which would effectively make it the root node of a mini subtree of the larger tree structure.

DAGs: A cycle in a diagraph or directed graph G is a set of edges 
The applications of DAGs include the following:
(1) Inheritance between C++ classes or Java interfaces.
(2) Prerequisites between courses of a degree program.
(3) Scheduling constraints between the tasks of a projects.

** In-order Traversal (left-root-right)
// non-recursive javascript program for inorder traversal

/* Class containing left and right child of
current node and key value*/

function inorder(root){
	if (root == null)
		return;
		
	var s = [];	
	var curr = root;

		// traverse the tree
	while (curr != null || s.length > 0){

		/* Reach the left most Node of the curr Node */
	   while (curr != null) {
		/* place pointer to a tree node on the stack before traversing the node's left subtree */
		s.push(curr);
		curr = curr.left;
	 }

		/* Current must be NULL at this point */
		curr = s.pop();

		/* we have visited the node and its left subtree. Now, it's right subtree's turn */
		curr = curr.right;
		}
	}

** Pre-order Traversal(root-left-right)

// Iterative function to do Preorder
// traversal of the tree
function preorderiterative(node) {

	if (node == null){
		return;
	}

	let st = [];

	// Start from root node (set curr
	// node to root node)
	let curr = node;

	// Run till stack is not empty or
	// current is not NULL
while (curr != null || st.length > 0){
		
		// Print left children while exist
		// and keep pushing right into the
		// stack.
	while (curr != null){
			if (curr.right != null)
				st.push(curr.right);

			curr = curr.left;
		}

		// We reach when curr is NULL, so We
		// take out a right child from stack
		if (st.length > 0)
		{
			curr = st.pop();
		}
	}
}

** Post-order Traversal (left-right-root)
// JavaScript program for iterative post-order
// order using two stacks

function postOrderIterative(root) {
		// Two stacks as used in explanation
		// Create two stacks
		var s1 = [];
		var s2 = [];

		if (root == null) return;

		// Push root to first stack
		s1.push(root);

		// Run while first stack is not empty
		while (s1.length > 0) {
		
		// Pop an item from s1 and Push it to s2
		var temp = s1.pop();
		s2.push(temp);

		// Push left and right children of
		// removed item to s1
		
		if (temp.left != null) s1.push(temp.left);
		if (temp.right != null) s1.push(temp.right);
		}

		// Print all elements of second stack
		while (s2.length > 0) {
		var temp = s2.pop();
		document.write(temp.data + " ");
		}
}





// Javascript program to print DFS(Depth First Search or DFS for a Graph)
// traversal from a given graph

// This class represents a
// directed graph using adjacency
// list representation
class Graph
{
	
	// Constructor
	constructor(v)
	{
		this.V = v;
		this.adj = new Array(v);
		for(let i = 0; i < v; i++)
			this.adj[i] = [];
	}
	
	// Function to add an edge into the graph
	addEdge(v, w)
	{
		
		// Add w to v's list.
		this.adj[v].push(w);
	}
	
	// A function used by DFS
	DFSUtil(v, visited)
	{
		
		// Mark the current node as visited and print it
		visited[v] = true;
		document.write(v + " ");

		// Recur for all the vertices adjacent to this
		// vertex
		for(let i of this.adj[v].values())
		{
			let n = i
			if (!visited[n])
				this.DFSUtil(n, visited);
		}
	}
	
	// The function to do DFS traversal.
	// It uses recursive
	// DFSUtil()
	DFS(v)
	{
		
		// Mark all the vertices as
		// not visited(set as
		// false by default in java)
		let visited = new Array(this.V);
		for(let i = 0; i < this.V; i++)
			visited[i] = false;

		// Call the recursive helper
		// function to print DFS
		// traversal
		this.DFSUtil(v, visited);
	}
}

// Driver Code
g = new Graph(4);

g.addEdge(0, 1);
g.addEdge(0, 2);
g.addEdge(1, 2);
g.addEdge(2, 0);
g.addEdge(2, 3);
g.addEdge(3, 3);

document.write("Following is Depth First Traversal " +
			"(starting from vertex 2)<br>");

g.DFS(2);


// updated version

	// This class represents a
	// directed graph using adjacency
	// list representation
	class Graph
	{
	
		// Constructor
		constructor(v) {
		this.V = v;
		this.adj = new Array(v).fill([]);
		}

		// Function to Add an edge into the graph
		AddEdge(v, w) {
		this.adj[v].push(w); // Add w to v's list.
		}

		// A function used by DFS
		DFSUtil(v, visited)
		{
		
		// Mark the current
		// node as visited and print it
		visited[v] = true;
		document.write(v + " ");

		// Recur for all the
		// vertices adjacent to this
		// vertex
		for (const n of this.adj[v]) {
			if (!visited[n]) this.DFSUtil(n, visited);
		}
		}

		// The function to do
		// DFS traversal. It uses recursive
		// DFSUtil()
		DFS()
		{
		
		// Mark all the vertices as not visited(set as
		var visited = new Array(this.V).fill(false);

		// Call the recursive helper
		// function to print DFS
		// traversal starting from
		// all vertices one by one
		for (var i = 0; i < this.V; ++i)
			if (visited[i] == false) this.DFSUtil(i, visited);
		}
	}
	
	// Driver Code
	var g = new Graph(4);

	g.AddEdge(0, 1);
	g.AddEdge(0, 2);
	g.AddEdge(1, 2);
	g.AddEdge(2, 0);
	g.AddEdge(2, 3);
	g.AddEdge(3, 3);

	document.write("Following is Depth First Traversal<br>");

	g.DFS();
	


