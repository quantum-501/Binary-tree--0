浏览器页面循环系统：
消息队列输入或输出任务按照先进先出顺序给事件循环主线程中执行，i/o进程不仅接受网络进程和浏览器上任务而且将每项交互事件给消息队列
为了解决执行任务实时性和效率性，算入微任务

浏览器页面加载流水线：
加载主页面 --阻止-- 构建dom（响应html数据） --阻止--  执行javascript(v8事件循环)---继续构建dom---构建cssom（css解析）---构建布局树---渲染---分层--分快--合成
｜       HTMLparser解析|    |(预解析）                  ｜(响应javascript数据）                ｜(响应javascript数据）                ｜
网络资源请求 ------------    ----开始请求javascript文件----                                    ｜                                  帧（显示屏提供）
                           -----开始请求css文件-----------------------------------------------
                            

网络连接
http1出现应对万维网产生的数据苛刻要求日益增长,支撑多种数据类型，数据文件大小，数据编码形式，语言版本来应对多样化网络需求，在这基础上,引出数据压缩,服务器处理状态码,cache缓存处理,
用户数量（称为用户代理）；
持续更新的http1.1:持久tcp连接,一域名有六个tcp连接,域名分片机制,队头阻塞,虚拟机支持为解决不同主机ip的host字段,数据分割多个小数据包,动态内容；

依然存在问题是：底宽利用率低,因为tcp慢启动,多个tcp连接会竞争固定带宽，队头阻塞；
为解决这个问题，http2提出了多路复用：一个域名对应一个持久tcp连接和消除队头阻塞。实现原理，将post带有的请求头行体进入二进制分帧层，被其带上id编号帧传入服务器，然后整体处理再返回到
二进制分帧层，被根据id回应原请求。另外也增加了请求优先级,头部压缩,服务器推送（直接拿html后，等于拿到html附带css和js文件一起被解析）

TCP的队头堵塞，网络延迟和协议僵化，无法让http有更大进展，所以http3出来了基于udp的quic协议，绕过tcp协议
拥有：多线路复用，快速握手（0或1rtt连接),tls1.3，传输可靠，流量控制等功能



Trees — like linked lists — are made up of nodes and links.

- Root: the topmost node of the tree, which never has any links or edges connecting to it
- Link/Edge: the reference that a parent node contains that tells it what its child node is
- Child: any node that has a parent node that links to it
- Parent: any node that has a reference or link to another node
- Sibling: any group of nodes that are the children of the same node
- Internal: any node that has a child node (basically all parent nodes)
- Leaf: any node that does not have a child node in the tree

If a tree has n nodes, it will always have one less number of edges (n-1).

For the most part, the two properties that we will be the most concerned with are either the depth of a node or the height of a node.

The child node of a tree structure could also very well be the parent node to many other child nodes — which would effectively make it the root node of a mini subtree of the larger tree structure.

DAGs: A cycle in a diagraph or directed graph G is a set of edges 
The applications of DAGs include the following:
(1) Inheritance between C++ classes or Java interfaces.
(2) Prerequisites between courses of a degree program.
(3) Scheduling constraints between the tasks of a projects.

** In-order Traversal (left-root-right)
// non-recursive javascript program for inorder traversal

/* Class containing left and right child of
current node and key value*/

function inorder(root){
	if (root == null)
		return;
		
	var s = [];	
	var curr = root;

		// traverse the tree
	while (curr != null || s.length > 0){

		/* Reach the left most Node of the curr Node */
	   while (curr != null) {
		/* place pointer to a tree node on the stack before traversing the node's left subtree */
		s.push(curr);
		curr = curr.left;
	 }

		/* Current must be NULL at this point */
		curr = s.pop();

		/* we have visited the node and its left subtree. Now, it's right subtree's turn */
		curr = curr.right;
		}
	}

** Pre-order Traversal(root-left-right)

// Iterative function to do Preorder
// traversal of the tree
function preorderiterative(node) {

	if (node == null){
		return;
	}

	let st = [];

	// Start from root node (set curr
	// node to root node)
	let curr = node;

	// Run till stack is not empty or
	// current is not NULL
while (curr != null || st.length > 0){
		
		// Print left children while exist
		// and keep pushing right into the
		// stack.
	while (curr != null){
			if (curr.right != null)
				st.push(curr.right);

			curr = curr.left;
		}

		// We reach when curr is NULL, so We
		// take out a right child from stack
		if (st.length > 0)
		{
			curr = st.pop();
		}
	}
}

** Post-order Traversal (left-right-root)
// JavaScript program for iterative post-order
// order using two stacks

function postOrderIterative(root) {
		// Two stacks as used in explanation
		// Create two stacks
		var s1 = [];
		var s2 = [];

		if (root == null) return;

		// Push root to first stack
		s1.push(root);

		// Run while first stack is not empty
		while (s1.length > 0) {
		
		// Pop an item from s1 and Push it to s2
		var temp = s1.pop();
		s2.push(temp);

		// Push left and right children of
		// removed item to s1
		
		if (temp.left != null) s1.push(temp.left);
		if (temp.right != null) s1.push(temp.right);
		}

		// Print all elements of second stack
		while (s2.length > 0) {
		var temp = s2.pop();
		document.write(temp.data + " ");
		}
}





// Javascript program to print DFS(Depth First Search or DFS for a Graph)
// traversal from a given graph

// This class represents a
// directed graph using adjacency
// list representation
class Graph
{
	
	// Constructor
	constructor(v)
	{
		this.V = v;
		this.adj = new Array(v);
		for(let i = 0; i < v; i++)
			this.adj[i] = [];
	}
	
	// Function to add an edge into the graph
	addEdge(v, w)
	{
		
		// Add w to v's list.
		this.adj[v].push(w);
	}
	
	// A function used by DFS
	DFSUtil(v, visited)
	{
		
		// Mark the current node as visited and print it
		visited[v] = true;
		document.write(v + " ");

		// Recur for all the vertices adjacent to this
		// vertex
		for(let i of this.adj[v].values())
		{
			let n = i
			if (!visited[n])
				this.DFSUtil(n, visited);
		}
	}
	
	// The function to do DFS traversal.
	// It uses recursive
	// DFSUtil()
	DFS(v)
	{
		
		// Mark all the vertices as
		// not visited(set as
		// false by default in java)
		let visited = new Array(this.V);
		for(let i = 0; i < this.V; i++)
			visited[i] = false;

		// Call the recursive helper
		// function to print DFS
		// traversal
		this.DFSUtil(v, visited);
	}
}

// Driver Code
g = new Graph(4);

g.addEdge(0, 1);
g.addEdge(0, 2);
g.addEdge(1, 2);
g.addEdge(2, 0);
g.addEdge(2, 3);
g.addEdge(3, 3);

document.write("Following is Depth First Traversal " +
			"(starting from vertex 2)<br>");

g.DFS(2);


// updated version

	// This class represents a
	// directed graph using adjacency
	// list representation
	class Graph
	{
	
		// Constructor
		constructor(v) {
		this.V = v;
		this.adj = new Array(v).fill([]);
		}

		// Function to Add an edge into the graph
		AddEdge(v, w) {
		this.adj[v].push(w); // Add w to v's list.
		}

		// A function used by DFS
		DFSUtil(v, visited)
		{
		
		// Mark the current
		// node as visited and print it
		visited[v] = true;
		document.write(v + " ");

		// Recur for all the
		// vertices adjacent to this
		// vertex
		for (const n of this.adj[v]) {
			if (!visited[n]) this.DFSUtil(n, visited);
		}
		}

		// The function to do
		// DFS traversal. It uses recursive
		// DFSUtil()
		DFS()
		{
		
		// Mark all the vertices as not visited(set as
		var visited = new Array(this.V).fill(false);

		// Call the recursive helper
		// function to print DFS
		// traversal starting from
		// all vertices one by one
		for (var i = 0; i < this.V; ++i)
			if (visited[i] == false) this.DFSUtil(i, visited);
		}
	}
	
	// Driver Code
	var g = new Graph(4);

	g.AddEdge(0, 1);
	g.AddEdge(0, 2);
	g.AddEdge(1, 2);
	g.AddEdge(2, 0);
	g.AddEdge(2, 3);
	g.AddEdge(3, 3);

	document.write("Following is Depth First Traversal<br>");

	g.DFS();
	


