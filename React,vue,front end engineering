Background checking:

Running-Cycling----潜在问题的回答内容----关键渲染路径
为了优化性能做出了哪些努力，因为web性能包括服务器请求和响应、加载、执行脚本、渲染、布局和绘制每个像素到屏幕上，为了<<优化渲染时间>>所做了一下措施：
-- CSS动画transition和animation与JavaScript动画requestAnimationFrame()在GPU计算上并无多大差距，帧速率(fps)也没差距，但是css动画不会涉及重绘(浏览器优化渲染流程)，而js动画
做不到,不过复杂动画需要使用js动画。如果css想要不占据主线并激活OMTA（脱离主线程的动画),前往火狐浏览器about:config然后搜索layers.offmainthreadcomposition.async-animations，
切换到true，CSS动画帧速率就高多了。
-- 【DOM文本对象模型】节点数量越多，关键渲染路径中的后续事件将花费的时间就越长
-- 【CSS对象模型】随着CSS解析而被构建,但是不能用来构建渲染树，因为样式将会被之后的解析所覆盖而不应该被渲染到屏幕上,从选择器性能角度，更少的特定选择器是比更多的要快。例如.foo {}是比
   .bar .foo{}更快,因为当浏览器发现.foo接下来必须沿着DOM向上走来检查.foo是不是有祖先.bar
-- 【渲染树】包括了内容和样式，DOM和CSSOM树结合，从DOM树的根节点开始遍历并决定哪些CSS规则被添加，也只包含可见内容
-- 【布局】决定了where和how在页面上放置元素，每个元素的宽和高及他们之间相关性,同时取决于屏幕尺寸。布局性能受DOM影响(节点数越多,布局就需要更长的时间).如果期间需要滚动或者其他动画将会导致
   迟滞。20ms 的延迟在加载或者方向改变时或许还可以接受，但在动画或滚动时就会迟滞。所以为了减小布局事件的频率和时长，批量更新或者避免改动盒模型属性，否则就会持续迟滞
-- 【绘制】不是影响性能大方面，当测量一个动画帧需要时间需要考虑到布局和重绘时间。添加到节点的样式会增加渲染时间，但是移除样式增加的0.001ms或许不能让你的优化物有所值.
-- 提升页面加载速度通过控制被加载资源的优先级、加载的顺序和减小体积: 1)通过异步,延迟加载或者消除非关键资源来减少关键资源的请求数量，2)优化必须的请求数量和每个请求的文件体积，
   3)通过区分关键资源的优先级来优化被加载关键资源的顺序，来缩短关键路径长度
      
优化关键渲染路径可以缩短首次渲染的时间。了解和优化关键渲染路径对于确保重排和重绘可以每秒 60 帧的速度进行，以确保高效的用户交互并避免讨厌是很重要的

Data visualization to aid dance training-----潜在问题的回答内容---复杂图形(渲染效率问题和计算问题)
-- 渲染效率问题指的是图形系统在绘图部分所花费的时间，而计算问题则是指绘图之外的其他处理所花费的时间，包括图形数据的计算、正常的程序逻辑处理等等；例如在浏览器上渲染动画每秒最高达到60帧。
   也就是在1秒钟内完成60次图像的绘制，那么完成一次图像绘制时间就是1000/60（1秒=1000毫秒),约等于16毫秒,复杂图形达不到60帧所以就需要更长毫秒 --
-- 影响Canvas和svg渲染性能的主要因素有两点，一是绘制图形的数量，二是绘制图形的大小
-- 影响WebGL性能主要有三点决定因素：一是渲染次数（因为WebGL支持批量渲染,绘制元素多不一定次数多），二是顶点和片元着色器执行次数（前者和几何图形的顶点数有关，后者和图形的大小有关),
   三是着色器运算的复杂度(越复杂的处理逻辑消耗越大)，四是数据大小(影响没前三大)

zoom实习：
以页面加载性能为例子,计算秒开率(一秒之内打开的用户占用户总量的百分比,因为当加载时间低于1秒，用户体感差别不大了)来建立性能优化认知
    ｜
---因从url输入到浏览器生成所有内容与页面首次加载时间息息相关，所以网页加载时间,请求数量和体积都相关---从缓存,降低请求数,请求成本,传输体积提出技术方案
    ｜---缓存(客户端强缓存策略);请求成本(1.http控制隔段时间主动请求dns请求获取域名,不走系统dns，2.tcp/tls逻辑复用由服务器升级升级http2,尽量合并域名)
    |---请求数量(1.js,css打包到html，2.用js控制图片异步加载和懒加载，3.小型图片用data-url/i
    ｜---体积(1.尽量有svg/gradient替图片，2.据机型或网络状况控图片清晰度，3.避免用大背景图，4.锐化低清晰度的图片来提升体验）
    ｜
---1.纯管理(用纯粹的管理手段来执行方案)---2.制度化(用规则代替人的命令，指定责任人，通过培训、checklist、定期 review 等具体措施来保证实施)
   3.自动化(在一些重要的操作路径上设置规则,针对我们性能优化,有两个点适合做这件事：一个是把开发好的页面发布上线，另一个是开发好的页面 URL 投放到首页等处的链接)
   |
---数据采集（Performance API记录的性能数据),数据展现（用不同的数据可视化方案来展现性能数据）


React principle                                                                                                                                    hook原理
                              函数组件：某个状态发生变化时，我需要做什么                                                                                     ｜
                              class组件:某个生命周期中我需要用什么（挂载更新卸载阶段错误处理，渲染和提交阶段）                                                     ｜
                                         ｜                                                                           1.函数作为子组件                    ｜
                                         ｜-------------->组件设计模式>--------组件复用(父传子兄弟,但父或兄弟不需时)----------2.高阶组件(函数作为参数给子及其以下元素) ｜
JSX-声明式-直接写html标记又动态创建组件       ｜        解决class函数内状态无法外部调用导致生命周期有限且react未用到其继承-->>优点>>---1.逻辑复用2.同一业务逻辑放一起,关注分离 ｜
    ｜                                    ------｜                        |（为什么出现）                                                                    ｜
    ｜                                          ｜                        ｜                                                                               ｜
    ｜----------------------组件层级形成元素树---<<函数组件<<---hook用于目标勾数据源当其变化时,更新目标代码结果---->>使用规则>>----1.顶级作用域,自定义hooks和函数组件中有用-｜
                                  ｜                                                                                  2.不得在循环条件嵌套函数内使用
                                 ^｜                              1.能计算得到不要储存,尽量无状态由props获取数据            3.ESlint检查hooks使用
视图及相关逻辑,数据,交互等封装-->>--组件(react前端应用核心) -----原则>>----2.一组件对应一件事     
    ｜                          ｜    ｜----------------------->>>-------------全局context解决组件通信(共享上下午文数据)--通过根节点provider访问全局子节点consumer                
   View --<<<-- props(单向数据绑定) + state(状态更新,不方法)----独立UI框架外状态管理框架(组件平级通信更容易)----全局唯一store(放组件外)管理业务数据程序状态让页面多组件state共享
    ｜                                                                                                           ｜
Virtual Dom ->-differ算法----->-----计算与原Dom差异----->-----更新数据并全局渲染---｜                               Redux机制
    ｜                                      ｜                                                                     ｜
    ｜                        每层节点有唯一标识key,新旧对比中,                                          与react产生connect机制------------传给需要组件数据的store上
  Router                          旧节点消失或被替换就删除并更新                                                        ｜                                   ｜^
无感切换页面也是页面代码组织形式                ｜                                                                     ｜                     (connect原理)高阶组件
    ｜                                     ｜                                                 View(状态)------<subscribe<------store(JavaScript对象)->-传给
   作用                                  造成卡顿                                                 |                                |^
1.单页无感刷新2.url定位到页面3.语义资源         ｜                                                 Action(动作发起)---->disptach>----Reducer
    ｜                                fiber结构(线程）                                   (object函数,描述发生动作) ｜
url/hash/内存路由                           |                                                                   |异步action复用逻辑的使用模式
用hash变化监听URL变化让DOM操作模拟页面跳转      ｜                                                                  ｜
    ｜事件机制(先绑定dom上)                   ｜                                                                  ｜中间件可传递action给reducer也可构建新action
真实dom触发事件冒泡到dom对象上       让出CPU执行权,分批此延时执行                      Action-->--middleware(如果action是函数,就直接执行并dispatch传递给函数)-->--reducer
处理原生js事件,再处理react事件


生命周期          ---------------------------------------------->-------------->----------->----      Hook
                       创建                         更新                     卸载                      Useffect:执行一段与当前执行结果无关的代码,判断依赖并执行
                        ｜                          ｜                      ｜                        1.不提供第二个依赖项,2.仅渲染一后提供空依赖数组3.依赖变化后执行
                    constructor             props,state,foreUpdate          |                        Usestate:让函数组件维持状态
                        |                           |                       |                        usecallback:缓存回调函数，usecallback(fn,[deps])
     渲染阶段               - getDerivedStateFromProps -                     |                        useMemo:缓存计算, useMemo(fn,[deps])
                        |          shouldComponentUpdate                    |                        useref:多次渲染之间共享数据, useref(initialvalue)
                        |.                          |                       |                        useContext:定义全局状态, useref(myContext)
                                  -      Render       -                     ｜
    ------              |                           |                       |
                                         getSnapShotBeforeUpdate            ｜
                        |                           |                       |
    提交阶段                             react更新DOM和Refs                   ｜
                        |                           |                       |
                 componentDidMount          componentDidUpdate     componentWillunmount


前端工程化（代码部署，规范，性能提升）
｜                              
｜————————————————————————｜——————————————————————————｜——————————————————————————｜—————————————————————————｜—————————————————————｜——————
wepack项目构建          Babel转译js                 模块化开发------复用分治-------组件化开发                  css预编译
弥补浏览器不足                                          |                           ｜
                                                      |                            ｜
                                                      |                             ｜
                                                      |                              ｜
                                   ---|---------------|-------------|---              1.页面上每个独立,可视/交互
                                    Common.JS        AMD           CMD                区域视为一组件
                                       |              |依赖前置      |依赖就近书写        2.不同页面根据需要放相关组件       
                           定义新js模块并exports    异步模块定义                           即可组成完整的页面
                           require加载后test调用   define定义模块
                                                 require加载模块

前端模块化（https://blog.csdn.net/fu983531588/article/details/89309242）
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
Vue与react区别：
1.一组件对应一watcher监听并推送数据变化给虚拟dom中diff算法更新，
2.react虚拟dom元素树计算然后对比更新节点，会造成卡顿而引fiber架构把虚拟dom微观化形成链表，计算子-兄弟-父元素，不产生停止页面卡顿

Vue principle --- 思考数据怎么变化

MVVM模式：1.Model数据模型和业务逻辑都在层中定义;2.View代表UI视图，负责数据的展示;3.ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；
                                          （view model）
View ------------------<------------------DOM listeners-----------------<--------------Model
(DOM)------------------->-----------------DOM bindinging----------------->------------(plain javascript object)
                                       VUE(单向数据流/双向绑定且是语法糖)
                                             |            
                                数据流 = 状态管理器 + 父组件属性props + 组件状态data（状态和属性更新都未必触发响应式更新）
- 基本原理 -                                     

state+template
(对比机制和react一样)
     |                       \\\\\\响应式更新\\\\\\\\\\
Virtual DOM----<component-render-function<-----trigger    |------------可执行所有逻辑(异步函数/节流)
                                                   ^｜    |---对比之下---computed执行响应式数据,数据缓存和减少模板计算逻辑
                            seter->-数据更新时提醒->--｜    |^
render实例化-->--Data依赖转化成geter--->依赖性变化时>---watcher-------<<dep<<-----通知变化-----observer(监听属性)
              (object.defineproperty())                  ｜------添加订阅者-----^|
                        ^｜                              ｜^-----------绑定数据变动,更新函数--------------
                   响应式更新model                        更新                                         ^｜
                    与双向绑定无关                         ｜                                           ｜
                                                        View------<-初始化-<--<编译解析变量为数据<-----compile  >>>>>>>>>>>>
                                                                
